# Nobody else seems to have done Python bindings for xkb yet.
# Implement simple ones here - just enough to interpret keypresses
# from Wayland servers

from cffi import FFI as _FFI

xkb_ffi = _FFI()

xkb_ffi.cdef("""
struct xkb_context;
struct xkb_keymap;
struct xkb_state;
typedef uint32_t xkb_keycode_t;
typedef uint32_t xkb_mod_mask_t;
typedef uint32_t xkb_layout_index_t;

enum xkb_context_flags {
    /** Do not apply any context flags. */
    XKB_CONTEXT_NO_FLAGS = 0,
    /** Create this context with an empty include path. */
    XKB_CONTEXT_NO_DEFAULT_INCLUDES = 1,
    /**
     * Don't take RMLVO names from the environment.
     * @since 0.3.0
     */
    XKB_CONTEXT_NO_ENVIRONMENT_NAMES = 2
};
struct xkb_context *
xkb_context_new(enum xkb_context_flags flags);

void xkb_context_unref(struct xkb_context *context);

enum xkb_keymap_format {
    /** The current/classic XKB text format, as generated by xkbcomp -xkb. */
    XKB_KEYMAP_FORMAT_TEXT_V1 = 1
};
enum xkb_keymap_compile_flags {
    /** Do not apply any flags. */
    XKB_KEYMAP_COMPILE_NO_FLAGS = 0
};

struct xkb_keymap *
xkb_keymap_new_from_string(struct xkb_context *context, const char *string,
                           enum xkb_keymap_format format,
                           enum xkb_keymap_compile_flags flags);

void xkb_keymap_unref(struct xkb_keymap *keymap);

struct xkb_state *
xkb_state_new(struct xkb_keymap *keymap);

void xkb_state_unref(struct xkb_state *state);

enum xkb_state_component {
    /** Depressed modifiers, i.e. a key is physically holding them. */
    XKB_STATE_MODS_DEPRESSED = 1,
    /** Latched modifiers, i.e. will be unset after the next non-modifier
     *  key press. */
    XKB_STATE_MODS_LATCHED = 2,
    /** Locked modifiers, i.e. will be unset after the key provoking the
     *  lock has been pressed again. */
    XKB_STATE_MODS_LOCKED = 4,
    /** Effective modifiers, i.e. currently active and affect key
     *  processing (derived from the other state components).
     *  Use this unless you explictly care how the state came about. */
    XKB_STATE_MODS_EFFECTIVE = 8,
    /** Depressed layout, i.e. a key is physically holding it. */
    XKB_STATE_LAYOUT_DEPRESSED = 16,
    /** Latched layout, i.e. will be unset after the next non-modifier
     *  key press. */
    XKB_STATE_LAYOUT_LATCHED = 32,
    /** Locked layout, i.e. will be unset after the key provoking the lock
     *  has been pressed again. */
    XKB_STATE_LAYOUT_LOCKED = 64,
    /** Effective layout, i.e. currently active and affects key processing
     *  (derived from the other state components).
     *  Use this unless you explictly care how the state came about. */
    XKB_STATE_LAYOUT_EFFECTIVE = 128,
    /** LEDs (derived from the other state components). */
    XKB_STATE_LEDS = 256
};

enum xkb_state_component
xkb_state_update_mask(struct xkb_state *state,
                      xkb_mod_mask_t depressed_mods,
                      xkb_mod_mask_t latched_mods,
                      xkb_mod_mask_t locked_mods,
                      xkb_layout_index_t depressed_layout,
                      xkb_layout_index_t latched_layout,
                      xkb_layout_index_t locked_layout);

typedef uint32_t xkb_keysym_t;

xkb_keysym_t xkb_state_key_get_one_sym(struct xkb_state *state,
                                       xkb_keycode_t key);

int
xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key,
                       char *buffer, size_t size);

enum xkb_keysym_flags {
    /** Do not apply any flags. */
    XKB_KEYSYM_NO_FLAGS = 0,
    /** Find keysym by case-insensitive search. */
    XKB_KEYSYM_CASE_INSENSITIVE = 1
};

xkb_keysym_t
xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags);

int xkb_keysym_get_name(xkb_keysym_t keysym,
                        char *buffer,
                        size_t size);

""")

xkb = xkb_ffi.dlopen("libxkbcommon.so")

class _keepref(object):
    """Function wrapper that keeps a reference to another object."""
    def __init__(self, ref, func):
        self.ref = ref
        self.func = func
    def __call__(self, *args, **kwargs):
        self.func(*args, **kwargs)

class XKBError(Exception):
    pass

class KeyboardState(object):
    def __init__(self, keymap):
        state = xkb.xkb_state_new(keymap._keymap)
        if not state:
            raise XKBError("Couldn't create keyboard state")
        # Keep the keymap around to ensure it isn't collected too soon
        self._keymap = keymap
        self._state = xkb_ffi.gc(state, _keepref(xkb, xkb.xkb_state_unref))
    def update_mask(self, depressed_mods, latched_mods, locked_mods,
                    depressed_layout, latched_layout, locked_layout):
        xkb.xkb_state_update_mask(
            self._state, depressed_mods, latched_mods, locked_mods,
            depressed_layout, latched_layout, locked_layout)
    def get_keysym(self, keycode):
        return xkb.xkb_state_key_get_one_sym(self._state, keycode)
    def get_keysym_string(self, keycode):
        keysym = self.get_keysym(keycode)
        name = xkb_ffi.new("char[64]")
        l = xkb.xkb_keysym_get_name(keysym, name, 64)
        if l == -1:
            # Invalid keysym
            return
        return xkb_ffi.string(name).decode('utf8')
    def get_string(self, keycode):
        buf = xkb_ffi.new("char[64]")
        l = xkb.xkb_state_key_get_utf8(self._state, keycode, buf, 64)
        if l == 0:
            return
        return xkb_ffi.string(buf).decode('utf8')

class Keymap(object):
    def __init__(self, context, s):
        keymap = xkb.xkb_keymap_new_from_string(
            context._context, s, xkb.XKB_KEYMAP_FORMAT_TEXT_V1,
            xkb.XKB_KEYMAP_COMPILE_NO_FLAGS)
        if not keymap:
            raise XKBError("Couldn't create keymap")
        # Keep a reference to context to ensure it is not prematurely
        # collected
        self._context = context
        self._keymap = xkb_ffi.gc(keymap, _keepref(
            xkb, xkb.xkb_keymap_unref))
    def new_state(self):
        return KeyboardState(self)

class XKBContext(object):
    def __init__(self):
        context = xkb.xkb_context_new(xkb.XKB_CONTEXT_NO_FLAGS)
        if not context:
            raise XKBError("Couldn't create XKB context")
        self._context = xkb_ffi.gc(context, _keepref(xkb, xkb.xkb_context_unref))
    def keymap_from_string(self, s):
        return Keymap(self, s)
    def keysym_from_name(self, name):
        return xkb.xkb_keysym_from_name(name.encode('utf8'),
                                        xkb.XKB_KEYSYM_NO_FLAGS)

